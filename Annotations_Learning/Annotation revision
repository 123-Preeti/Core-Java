âœ… Annotation in Java â€“ Main Points (Bullet Points)
1. Definition

Annotations are metadata in Java.

They provide information to the compiler, JVM, and tools.

They do not change the actual program logic.

2. Purpose of Annotations

Provide instructions to compiler or runtime.

Reduce boilerplate code.

Support framework-based configuration.

Improve code readability and maintainability.

3. Types of Java Annotations

Built-in annotations (e.g., @Override, @Deprecated).

Meta-annotations (annotations that define other annotations).

Custom annotations (created using @interface).

4. Common Built-in Annotations

@Override â†’ Ensures method overriding.

@Deprecated â†’ Marks code as outdated.

@SuppressWarnings â†’ Suppresses compiler warnings.

5. Meta-Annotations

@Retention â†’ Defines how long annotation is kept (SOURCE, CLASS, RUNTIME).

@Target â†’ Specifies where annotation can be applied (method, class, field).

@Inherited â†’ Allows annotations to be inherited by subclasses.

@Documented â†’ Includes annotation in Javadoc.

6. Custom Annotations

Created using @interface.

Can contain elements (like variables).

Elements can have default values.

Accessed at runtime using Reflection.

7. Annotations Used in Frameworks

Spring: @Autowired, @Component, @RestController.

Hibernate/JPA: @Entity, @Id, @Column.

JUnit/TestNG: @Test, @BeforeEach, @AfterEach.

8. Benefits of Using Annotations

Cleaner and more readable code.

Less XML configuration.

Automated dependency injection & mapping.

Helps with compiler checking & error prevention.

Reduces repetitive code.

9. Best Practices

Use correct @Target for accurate placement.

Avoid overusing annotations.

Keep annotation definitions simple.

Document custom annotations clearly.

Use annotations consistently across the project.



âœ… Annotations in Java â€“ Important Revision Points
ğŸ”¹ What is an Annotation?

Annotation provides metadata (extra information) about code

It does not change program logic

Used by compiler, JVM, or frameworks

ğŸ”¹ Syntax
@AnnotationName

ğŸ”¹ Why Annotations are Used?

Reduce code

Improve readability

Provide information to compiler/framework

Used in Spring, Hibernate, JUnit

ğŸ”¹ Built-in Annotations (Very Important â­)
1ï¸âƒ£ @Override

Checks method overriding

Gives compile-time error if method is not overridden correctly

@Override
public String toString() {
    return "Hello";
}

2ï¸âƒ£ @Deprecated

Marks method/class as outdated

Compiler gives warning if used

@Deprecated
void oldMethod() { }

3ï¸âƒ£ @SuppressWarnings

Suppresses compiler warnings

@SuppressWarnings("unchecked")

4ï¸âƒ£ @FunctionalInterface

Used with interfaces having only one abstract method

Used in Lambda expressions

@FunctionalInterface
interface Demo {
    void show();
}

ğŸ”¹ Meta-Annotations (Very Important â­â­)
Meta-Annotation	Use
@Retention	How long annotation is kept
@Target	Where annotation can be applied
@Documented	Appears in JavaDoc
@Inherited	Inherited by subclasses
ğŸ”¹ Retention Policy Types

SOURCE â†’ only in source code

CLASS â†’ stored in .class file

RUNTIME â†’ available at runtime (reflection)

ğŸ”¹ Target Types

METHOD

CLASS

FIELD

CONSTRUCTOR

PARAMETER

ğŸ”¹ Custom Annotation (Basic Idea)
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface MyAnnotation {
    String value();
}

ğŸ”¹ Important Exam Notes â­

Annotations start with @

@Override is most commonly used

Meta-annotations define annotation behavior

Annotations can be built-in or user-defined
